---
title: Profile
layout: default
hide: true
---

<script type="module">
    import { LitElement, html, css } from '/assets/global/libs/lit/lit-core.min.js'

    export class ProgressionItem {
        /** @type {string} */
        id

        /** @type {boolean} */
        checked

        /** @type {string} */
        label

        /**
         * @param {string} id
         * @param {boolean} checked
         * @param {string} label
         */
        constructor(id, checked, label) {
            this.id = id
            this.checked = checked
            this.label = label
        }

        static fromJSON(parentId, obj) {
            return new ProgressionItem(
                `${parentId}__${obj.id}`,
                false,
                obj.label,
            )
        }
        /**
         * @param {boolean} checked
         * @return {ProgressionItem}
         */
        copyWithChecked(checked) {
            return new ProgressionItem(this.id, checked, this.label)
        }

        get _localStorageKey() {
            return `progressions_item_checked_${this.id}`
        }

        persist() {
            localStorage.setItem(this._localStorageKey, this.checked)
        }

        /**
         * Returns a copy of this with all values restored 
         * from localStorage.
         *
         * @return {ProgressionItem}
         */
        restore() {
            return new ProgressionItem(
                this.id,
                localStorage.getItem(this._localStorageKey) === "true",
                this.label,
            )
        }
    }

    export class Progression {
        /** @type {string} */
        id

        /** @type {Array<ProgressionItem>} */
        items

        /** @type {string} */
        title

        /**
         * @return {float}
         */
        get progress() {
            const checkedItemsCount = this.items.filter((item) => item.checked === true).length

            if (checkedItemsCount == 0) return 0

            const totalItemsCount = this.items.length

            return checkedItemsCount / totalItemsCount
        }

        /**
         * @param {string} id
         * @param {string} title
         * @param {Array<ProgressionItem>} items
         */
        constructor(id, title, items) {
            this.id = id
            this.items = items
            this.title = title
        }

        static fromJSON(obj) {
            return new Progression(
                obj.id,
                obj.title,
                obj.items.map((item) => ProgressionItem.fromJSON(obj.id, item))
            )
        }

        /**
         * @param {ProgressionItem} itemToUpdate
         *
         * @return {Progression}
         */
        copyWithItem(itemToUpdate) {
            return new Progression(
                this.id,
                this.title,
                this.items.map((item) => {
                    if (item.id !== itemToUpdate.id) return item
                    return itemToUpdate
                }),
            )
        }

        /**
         * Returns a copy of this with all values restored 
         * from localStorage.
         *
         * @return {Progression}
         */
        restore() {
            return new Progression(
                this.id,
                this.title,
                this.items.map((item) => item.restore())
            )
        }
    }

    export class GlobalProgress {
        /** @type {Array<Progression>} */
        progressions

        /** @type {Array<string>} */
        steps

        /**
         *  @param {Array<string>} steps
         *  @param {Array<Progression>} progressions
         */
        constructor(steps, progressions) {
            this.steps = steps
            this.progressions = progressions
        }

        static fromJSON(obj) {
            return new GlobalProgress(
                obj.steps,
                obj.progressions.map(Progression.fromJSON)
            )
        }

        /**
         * @param {Progression} progressionToUpdate
         *
         * @return {GlobalProgress}
         */
        copyWithProgression(progressionToUpdate) {
            return new GlobalProgress(
                this.steps,
                this.progressions.map((progression) => {
                    if (progression.id !== progressionToUpdate.id) return progression
                    return progressionToUpdate
                })
            )
        }

        /**
         * Returns a copy of the GlobalProgress with all values restored 
         * from localStorage.
         *
         * @return {GlobalProgress}
         */
        restore() {
            return new GlobalProgress(
                this.steps,
                this.progressions.map((progression) => progression.restore())
            )
        }

        /**
         * @return {float}
         */
        get progress() {
            const allItems = this.progressions
                .map((progression) => progression.items)
                .flat()

            const checkedItemsCount = allItems.filter((item) => item.checked).length

            if (checkedItemsCount == 0) return 0
            const allItemsCount = allItems.length
            return checkedItemsCount / allItemsCount
        }

        /**
         * @return {int}
         */
        get fulfilledSteps() {
            return Math.floor((this.steps.length - 1) * this.progress)
        }

        /**
         * @return {string}
         */
        get currentStepLabel() {
            return this.steps[this.fulfilledSteps]
        }
    }
    export class ProgressCircleView extends LitElement {
        static properties = {
            value: { attribute: true },
            text: { attribute: true },
        }

        static styles = css`
        .progress-circle {
            font-size: 20px;
            margin: 20px;
            position: relative;
            /* so that children can be absolutely positioned */
            padding: 0;
            width: 5em;
            height: 5em;
            background-color: #F2E9E1;
            border-radius: 50%;
            line-height: 5em;
        }

        .progress-circle:after {
            border: none;
            position: absolute;
            top: 0.35em;
            left: 0.35em;
            text-align: center;
            display: block;
            border-radius: 50%;
            width: 4.3em;
            height: 4.3em;
            background-color: white;
            content: " ";
        }


        /* Text inside the control */

        .progress-circle span {
            position: absolute;
            line-height: 5em;
            width: 5em;
            text-align: center;
            display: block;
            color: #08a1db;
            z-index: 2;
        }

        .left-half-clipper {
            /* a round circle */
            border-radius: 50%;
            width: 5em;
            height: 5em;
            position: absolute;
            /* needed for clipping */
            clip: rect(0, 5em, 5em, 2.5em);
            /* clips the whole left half*/
        }


        /* when p>50, don't clip left half*/

        .progress-circle.over50 .left-half-clipper {
            clip: rect(auto, auto, auto, auto);
        }

        .value-bar {
            /*This is an overlayed square, that is made round with the border radius,
            then it is cut to display only the left half, then rotated clockwise
            to escape the outer clipping path.*/
            position: absolute;
            /*needed for clipping*/
            clip: rect(0, 2.5em, 5em, 0);
            width: 5em;
            height: 5em;
            border-radius: 50%;
            border: 0.45em solid #08a1db;
            /*The border is 0.35 but making it larger removes visual artifacts */
            /*background-color: #4D642D;*/
            /* for debug */
            box-sizing: border-box;
            transition: transform 0.6s;
        }


        /* Progress bar filling the whole right half for values above 50% */

        .progress-circle.over50 .first50-bar {
            /*Progress bar for the first 50%, filling the whole right half*/
            position: absolute;
            /*needed for clipping*/
            clip: rect(0, 5em, 5em, 2.5em);
            background-color: #08a1db;
            border-radius: 50%;
            width: 5em;
            height: 5em;
        }

        .progress-circle:not(.over50) .first50-bar {
            display: none;
        }
        `

        render() {
            return html`
            <div class="progress-circle">
                <span>${this.text}</span>
                <div class="left-half-clipper">
                <div class="first50-bar"></div>
                <div class="value-bar"></div>
            </div>
            `
        }

        _updateClipFirstHalf() {
            const progressCircle = this.renderRoot.querySelector('.progress-circle')
            if (this.value > 0.5) {
                progressCircle.classList.add('over50')
            } else {
                progressCircle.classList.remove('over50')
            }

        }
        _updateRotation() {
            const valueBar = this.renderRoot.querySelector('.value-bar')
            const angle = Math.round(this.value * 360);

            valueBar.style.transform = `rotate(${angle}deg)`

        }
        updated() {
            this._updateClipFirstHalf()
            this._updateRotation()
        }
    }
    customElements.define('progress-circle', ProgressCircleView);

    export class ProgressBarView extends LitElement {
        static properties = {
            value: { attribute: true }
        }

        static styles = css`
        .progress-bar {
            display: flex;
            flex-direction: column;
            justify-content: center;
            overflow: hidden;
            text-align: center;
            white-space: nowrap;
            transition: 
                width 0.6s ease,
                background-color 0.6s ease;
        }
        .progress, .progress-stacked {
            display: flex; 
            height: 6pt;
            overflow: hidden;
            background-color: white;
            border-radius: 6pt;
        }
        `;

        get percentValue() { return Math.round(this.value * 100) }

        render() {
            return html`
            <div class="progress" role="progressbar">
                <div class="progress-bar" style="width: ${this.percentValue}%"></div>
            </div>
            `;
        }

        firstUpdated() {
        }

        interpolateColorComponent(start, end, progress) {
            return Math.round(start + progress * (end - start))
        }

        interpolateColors(start, end, progress) {
            return [
                this.interpolateColorComponent(start[0], end[0], progress),
                this.interpolateColorComponent(start[1], end[1], progress),
                this.interpolateColorComponent(start[2], end[2], progress),
            ]
        }

        updated() {
            const color1 = [249, 124, 27]
            const color2 = [154, 212, 201]
            const progressbar = this.renderRoot.querySelector('.progress-bar')

            const interpolatedColor = this.interpolateColors(color1, color2, this.value)
            progressbar.style.backgroundColor = `rgb(${interpolatedColor[0]},${interpolatedColor[1]},${interpolatedColor[2]})`

        }
    }
    customElements.define('progress-bar', ProgressBarView);

    export class GlobalProgressView extends LitElement {
        static properties = {
            /** @type {GlobalProgress} */
            globalProgress: { attribute: false }
        }

        // Define scoped styles right with your component, in plain CSS
        static styles = css`
        h2 {
            margin-bottom: 8pt
        }
        ul {
            list-style: none;
            padding-left: 0;
        }
        
        .global-progress {
            display: flex;
            align-items: center;
            width: 300pt;
        }

        progress-bar {
            display: block;
            max-width: 500pt;
        }
        `;

        constructor() {
            super();

            const progs = JSON.parse(this.getAttribute('progressions'))
            // Declare reactive properties
            this.globalProgress = GlobalProgress.fromJSON(progs).restore();
        }

        /**
         * @param {Progression} progression
         * @param {ProgressionItem} progressionItem
         */
        toggleItem(progression, progressionItem) {
            const updatedItem = progressionItem.copyWithChecked(!progressionItem.checked)
            updatedItem.persist()
            this.globalProgress = this.globalProgress.copyWithProgression(
                progression.copyWithItem(
                    updatedItem
                )
            )
        }

        /**
         * @param {ProgressionItem} progressionItem
         */
        renderProgressionItem(that, progression, progressionItem) {
            return html`<li>
                <input
                    id="${progressionItem.id}"
                    type="checkbox" 
                    ?checked=${progressionItem.checked}
                    @click="${() =>
                    this.toggleItem(progression, progressionItem)}"
                    ></input> 
                <label for="${progressionItem.id}">${progressionItem.label}</label>
            </li>`
        }

        /**
         * @param {Progression} progression
         */
        renderProgression(that, progression) {
            return html`<section>
                <h2>${progression.title} : </h2>
                <progress-bar value="${progression.progress}"></progress-bar>
                <ul>
                    ${progression.items.map((item) => that.renderProgressionItem(that, progression, item))}
                </ul>
            </section>`
        }

        // Render the UI as a function of component state
        render() {
            return html`
            <section class="global-progress"> 
                <progress-circle value="${this.globalProgress.progress}" text="${this.globalProgress.fulfilledSteps} / ${this.globalProgress.steps.length - 1}"></progress-circle>
                <div>${this.globalProgress.currentStepLabel}</div>
            </section>
            ${this.globalProgress.progressions.map((progression) => this.renderProgression(this, progression))}
            `;
        }
    }
    customElements.define('global-progression', GlobalProgressView);
</script>
<div class="width--wide page__top-content page__bottom-content">
    <h1 class="margin-bottom--none">{{site.data.profile.journey.title}}</h1>

    <global-progression progressions='{{site.data.profile.journey.global_progress | jsonify}}'>
    </global-progression>
</div>